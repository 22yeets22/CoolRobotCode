{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      PongButInVexIQ\n# \tAuthor:       3030C Biscuiteers\n# \tCreated:      10/8/2023\n# \tDescription:  Pong But In Vex IQ\n# \n# ------------------------------------------\n\nimport math\nfrom vex import *\nfrom random import uniform, choice\n\n\n# Constants\nSCREEN_WIDTH, SCREEN_HEIGHT = 159, 107\n\n# Ball variables\nBALL_COLOR = Color.BLUE_GREEN\nBALL_START_VELOCITY_RANGE = [1.5, 3]\nBALL_RADIUS = 4\nBALL_WALL_BOUNCE_FRICTION = 0.95\nBALL_PADDLE_BOUNCE_SPEED = 1.1\nBALL_JITTER = 0.1  # Velocity jitter\n# Paddle variables\nPADDLE_COLOR = Color.WHITE\nPADDLE_DISTANCE_TO_WALL = 15\nPADDLE_WIDTH = 8\nPADDLE_HEIGHT = 17\nPADDLE_SPEED = 0.007\nPADDLE_FRICTION = 0.93\n# Environment variables\nLINE_COLOR = Color.YELLOW_GREEN\n\nleft_score = 0\nright_score = 0\n\n\ndef random_ball_velocity():\n    return uniform(BALL_START_VELOCITY_RANGE[0], BALL_START_VELOCITY_RANGE[1]) * choice([-1, 1])\n\n\ndef random_ball_jitter():\n    return uniform(-BALL_JITTER, BALL_JITTER)\n\n\ndef circle_rect_collision(circle_center, circle_radius, circle_velocity, rect_position, rect_width, rect_height, rect_velocity):\n    relative_velocity_x = circle_velocity[0] - rect_velocity[0]\n    relative_velocity_y = circle_velocity[1] - rect_velocity[1]\n    \n    closest_x = max(rect_position[0], min(circle_center[0], rect_position[0] + rect_width))\n    closest_y = max(rect_position[1], min(circle_center[1], rect_position[1] + rect_height))\n\n    dist_x = circle_center[0] - closest_x\n    dist_y = circle_center[1] - closest_y\n    dist_squared = dist_x**2 + dist_y**2\n\n    if dist_squared <= circle_radius**2:\n        if dist_squared == 0:\n            # Handle zero-division error by reflecting velocity\n            return -circle_velocity[0] + random_ball_jitter(), -circle_velocity[1] + random_ball_jitter()\n        else:\n            # Collision occurred, calculate the new velocity by reflecting the old one\n            dot_product = (relative_velocity_x * dist_x + relative_velocity_y * dist_y) / dist_squared\n            new_relative_velocity_x = relative_velocity_x - 2 * dot_product * dist_x\n            new_relative_velocity_y = relative_velocity_y - 2 * dot_product * dist_y\n\n            # Add back the rect's velocity to get the new circle velocity\n            new_velocity_x = new_relative_velocity_x + rect_velocity[0]\n            new_velocity_y = new_relative_velocity_y + rect_velocity[1]\n            \n            return (new_velocity_x + random_ball_jitter(), new_velocity_y + random_ball_jitter())\n    else:\n        # No collision, return the original velocity\n        return circle_velocity\n\n\nclass Ball:\n    def __init__(self, x, y, radius, color_, vel_x=0, vel_y=0, wall_bounce_friction=0.95, paddle_bounce_speed=1.1):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.color_ = color_\n        self.vel_x = vel_x\n        self.vel_y = vel_y\n        self.wall_bounce_friction = wall_bounce_friction\n        self.paddle_bounce_speed = paddle_bounce_speed\n\n    def update(self, left_paddle, right_paddle):\n        global left_score, right_score\n\n        # Velocities\n        self.x += self.vel_x\n        self.y += self.vel_y\n        \n        # Wall bouncing\n        if self.y < self.radius:\n            self.y = self.radius\n            self.vel_x *= self.wall_bounce_friction\n            self.vel_y *= -self.wall_bounce_friction\n        elif self.y > SCREEN_HEIGHT - self.radius:\n            self.y = SCREEN_HEIGHT - self.radius\n            self.vel_x *= self.wall_bounce_friction\n            self.vel_y *= -self.wall_bounce_friction\n        \n        # Win\n        if self.x < -self.radius:\n            right_score += 1\n            brain.play_sound(SoundType.FILLUP)\n            self.x, self.y = SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2\n            self.vel_x, self.vel_y = random_ball_velocity(), random_ball_velocity()\n        elif self.x > self.radius + SCREEN_WIDTH:\n            left_score += 1\n            brain.play_sound(SoundType.FILLUP)\n            self.x, self.y = SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2\n            self.vel_x, self.vel_y = random_ball_velocity(), random_ball_velocity()\n        \n        # Paddle collision\n        if self.x < PADDLE_DISTANCE_TO_WALL + PADDLE_WIDTH * 2:\n            self.vel_x, self.vel_y = circle_rect_collision([self.x, self.y], self.radius, [self.vel_x, self.vel_y], [left_paddle.x, left_paddle.y], left_paddle.width_, left_paddle.height_, [0, left_paddle.vel_y])\n        elif self.x > SCREEN_WIDTH - PADDLE_DISTANCE_TO_WALL - PADDLE_WIDTH * 2:\n            self.vel_x, self.vel_y = circle_rect_collision([self.x, self.y], self.radius, [self.vel_x, self.vel_y], [right_paddle.x, right_paddle.y], right_paddle.width_, right_paddle.height_, [0, left_paddle.vel_y])\n\n    def draw(self):\n        brain.screen.set_fill_color(self.color_)\n        brain.screen.draw_circle(self.x, self.y, self.radius)\n\n\nclass Paddle:\n    def __init__(self, x, y, width_, height_, color_, friction, vel_y=0):\n        self.x = x\n        self.y = y\n        self.width_ = width_\n        self.height_ = height_\n        self.color_ = color_\n        self.friction = friction\n        self.vel_y = vel_y\n\n    def update(self, vel_y):\n        # Velocity stuff\n        self.vel_y += vel_y\n        self.vel_y *= self.friction\n        self.y += self.vel_y\n\n        # Bounds checking\n        if self.y < 0:\n            self.y = 0\n            self.vel_y = 0\n        elif self.y > SCREEN_HEIGHT - PADDLE_HEIGHT:\n            self.y = SCREEN_HEIGHT - PADDLE_HEIGHT\n            self.vel_y = 0\n    \n    def draw(self):\n        brain.screen.set_fill_color(self.color_)\n        brain.screen.draw_rectangle(self.x, self.y, self.width_, self.height_)\n\n\n# Variables\nball = Ball(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, BALL_RADIUS, BALL_COLOR, random_ball_velocity(), random_ball_velocity(), BALL_WALL_BOUNCE_FRICTION, BALL_PADDLE_BOUNCE_SPEED)\nleft_paddle = Paddle(PADDLE_DISTANCE_TO_WALL, SCREEN_HEIGHT / 2 - PADDLE_HEIGHT / 2, PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_COLOR, PADDLE_FRICTION)\nright_paddle = Paddle(SCREEN_WIDTH - PADDLE_DISTANCE_TO_WALL - PADDLE_WIDTH, SCREEN_HEIGHT / 2 - PADDLE_HEIGHT / 2, PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_COLOR, PADDLE_FRICTION)\n\nbrain.screen.set_font(FontType.MONO20)\nwhile True:\n    # Buttons / inputs\n    if abs(controller.axisA.position()) > 5: left_movement = controller.axisA.position() * -PADDLE_SPEED  # Y axis is inverted\n    else: left_movement = 0\n    if abs(controller.axisD.position()) > 5: right_movement = controller.axisD.position() * -PADDLE_SPEED  # Y axis is inverted\n    else: right_movement = 0\n\n    if left_score >= 5:\n        brain.screen.set_pen_color(Color.YELLOW_ORANGE)\n        brain.screen.set_font(FontType.MONO20)\n        brain.screen.set_cursor(3, 4)\n        brain.screen.print(\"Left Wins!\")\n        brain.play_sound(SoundType.TADA)\n        break\n    if right_score >= 5:\n        brain.screen.set_pen_color(Color.YELLOW_ORANGE)\n        brain.screen.set_font(FontType.MONO20)\n        brain.screen.set_cursor(3, 3)\n        brain.screen.print(\"Right Wins!\")\n        brain.play_sound(SoundType.TADA)\n        break\n\n    # Update before drawing\n    left_paddle.update(left_movement)\n    right_paddle.update(right_movement)\n    ball.update(left_paddle, right_paddle)\n\n    # To minimize draw screen lag, only nesscary code after clearing screen and finish drawing\n    # Clear the screen, draw paddles, draw the ball, line in the middle, and the scores\n    brain.screen.clear_screen()\n    \n    # Draw line in the middle\n    brain.screen.set_pen_width(1)\n    brain.screen.set_pen_color(LINE_COLOR)\n    brain.screen.draw_line(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT)\n    brain.screen.set_pen_width(0)\n\n    # Draw paddles and balls\n    left_paddle.draw()\n    right_paddle.draw()\n    ball.draw()\n\n    # Draw score\n    brain.screen.set_fill_color(Color.BLACK)\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.set_cursor(1, 7)\n    brain.screen.print(left_score)\n    brain.screen.set_cursor(1, 10)\n    brain.screen.print(right_score)\n\n    wait(30, MSEC)\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22}],"slot":7,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.1","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}
